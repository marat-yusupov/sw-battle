# Процесс симуляции (алгоритм работы программы)

При запуске программы пользователь передает список команд. Парсер обрабатывает команды и на выходе получается список объектов-комманд, у которых есть один единственный метод "execute".

В класс симулятора (синглтон) передается список команд, которые необходимо выполнить за первый тик программы.

После выполнения команд, симулятор запускает цикл итераций (цикл тиков боя). За каждый тик мы берем список существующих на карте юнитов (список обновляется каждый тик, чтобы следить за тем, чтобы выбывшие юниты не совершали действий). За тик, каждый юнит совершает свое одно действие (движение к точке или аттаку). Если юнитов осталось меньше двух или все действия юнитов считаются завершенными - симуляция завершается.

# Сущности

## Command
* Params -  список параметров команды
```cpp
    /*
     * @details Выполнить команду. Каждый экземпляр команды переопределяет метод под свою реализацию.
     */
    virtual void execute(int tick) = 0;
```

Список реализаций (существующих комманд):

* CreateMap - создает карту, принимает аргументы в следующем порядке:
    * Width - ширина карты
    * Height - высота карты

* SpawnWarrior - создает на карте юнита-воина, принимает аргументы в следующем порядке:
    * Id - уникальный идентификатор юнита
    * X - координата X юнита на карте
    * Y - координата Y юнита на карте
    * HP - количество здоровья юнита
    * Strength - сила удара юнита

* SpawnArcher - создает на карте юнита-лучника, принимает аргументы в следующем порядке:
    * Id - уникальный идентификатор юнита
    * X - координата X юнита на карте
    * Y - координата Y юнита на карте
    * HP - количество здоровья юнита
    * Agility - сила удара для диапазонной атаки
    * Strength - сила удара юнита
    * Range - пограничное значение диапазона удара лучника.

* March - указывает существующему юниту куда ему переместиться на карте.
    * Id - уникальный идентификатор юнита
    * X - целевая координата X
    * Y - целевая координата Y

## Unit
* Id
* Characteristics [ HP (int) ]
* Position [ x ; y ]

```cpp
    /*
     * @details Выполнить ход за юнитом. Каждый экземпляр юнита переопределяет этот метод под свою реализацию
     * @params tick - тик, за который юнит в данный момент выполняет ход.
     * @params map - карта игрового мира. 
     * @return true - если юнит завершил свое действие, false - если юнит не завершил свое действие.
     */
    virtual bool start(int tick, resources::Map const &Map) = 0;
```

### Warrior
* Characteristics [ Strength (int) ]

### Archer 
* Characteristics [ Strength (int), Agility (int), Range (int) ]

## Action
```cpp
    /*
     * @details Запустить выполнение действия
     * @params tick - тик, за который в данный момент выполняется действие.
     */
    virtual void start(int tick) = 0;
```

### Move
* MovedUnut - юнит, которого требуется переместить
* TargetPosition - точка, к которой юнит должен придти. Задается командой March при инициализации.

### Attack
```cpp
    /*
     * @details Выбрать подходящую цель из списка юнитов по близости.
     */
    virtual UnitPtr selectTarget(UnitList const &targets);
```


#### MeleeAttack
* TargetList - список целей, которые находятся рядом с юнитом в пределах 1 клетки
* Strength - сила удара

#### RangeAttack
* TargetList - список целей, которые находятся в пределах от 2 до range клеток.
* Agility - сила удара

## Map
* Width - высота
* Height - ширина
* UnitList - список живых юнитов на карте

## Simulator
Синглтон, запускает игру и следит за ее завершением. 

```cpp
    /*
     * @details Запустить симуляцию 
     * @param commands - список комманд, которые необходимо выполнить за первый тик симуляции.
     */
    void run(commands::CommandList const &commands);
```

# Что можно улучшить 
1) Определить интерфейс атакующего юнита (например AttackUnit), от которого унаследуются юниты, у которых есть возможность аттаки (в данный момент Warrior и Archer)

2) Метод selectTarget() вынести в интерфейс атакующего юнита, передавать в действие-атаку уже выбранную цель. 

3) Интерфейс Attack. Нужен ли он в текущей реализации? Будут ли у аттак какие-то общие свойства? А может быть наоборот удалить реализации Melee- и Range-аттак, а оставить один интерфейс, куда будут передаваться характеристики аттаки (юнита, которого аттакуют и силу удара).

4) Параметр Range в RangeAttack не используется, его нужно удалить. Это характеристика именно юнита, а не аттаки.

5) Добавить юнит-тесты на каждую сущность. В текущий момент есть только функциональные тесты, которые проверяют результат всей программы при определенных сценариях.

6) Добавить негативные функциональные тесты. Нужно проверить, что некорректные действия пользователя обрабатываются нужным способом.

7) Подумать над логикой определения конца команды March. Сейчас логика завязана на опциональный параметр TargetPosition (целевая позиция) и валидация в нескольких местах дублируется (она присутствует и у сущности юнита и у самого действия Move).
